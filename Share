---

It seems like the user is asking for a simplified version of the solution. They're overwhelmed by the extra files being generated and want to focus on just rendering a single graph. They’re requesting a fixed PNG file (instead of timestamped ones) and a single CSV that overwrites the previous one. They also want the renderer logic updated to display this single PNG on the webpage. So, the focus now is on simplifying and fixing the output before addressing other issues.


Thought for 21 seconds


Let’s cut right to the chase and get a single, pre‐rendered PNG onto your page without any of the “multiple timestamped files” or HTTP‐calls. We’ll:

1. **Generate exactly one CSV and one PNG**, always overwriting the previous.
2. **On app startup**, run that generation once so the file exists on disk.
3. Serve it as a static file from **wwwroot/charts/**.
4. Render it in your Blazor page with a “Last updated” based on the file’s timestamp.

---

## 1) Update `ChartGeneratorService`

```csharp
// Services/ChartGeneratorService.cs
using System.Diagnostics;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using StarTrends.Models;

namespace StarTrends.Services
{
    public class ChartGeneratorService : IChartGeneratorService
    {
        private readonly ILogger<ChartGeneratorService> _logger;
        private readonly string _scriptsFolder;
        private readonly string _csvFolder;
        private readonly string _chartsFolder;

        public ChartGeneratorService(
            ILogger<ChartGeneratorService> logger,
            IConfiguration        config,
            IHostEnvironment      env)
        {
            _logger = logger;

            _scriptsFolder = Path.Combine(env.ContentRootPath,
                config["ChartScriptsPath"] ?? "PythonScripts");

            // Single CSV
            _csvFolder = Path.Combine(env.ContentRootPath,
                config["CsvOutputPath"] ?? "chart_data");

            // Single PNG under wwwroot/charts
            _chartsFolder = Path.Combine(env.ContentRootPath,
                "wwwroot",
                config["ChartsOutputPath"] ?? "charts");

            Directory.CreateDirectory(_scriptsFolder);
            Directory.CreateDirectory(_csvFolder);
            Directory.CreateDirectory(_chartsFolder);
        }

        public async Task<string> GenerateProductTradeChartAsync(IEnumerable<ProductTradeCount> data)
        {
            // fixed filenames
            var csvPath = Path.Combine(_csvFolder, "product_trades.csv");
            var pngPath = Path.Combine(_chartsFolder, "product_trades.png");

            // 1) write CSV (overwrites previous)
            await using var w = new StreamWriter(csvPath, false);
            w.WriteLine("ProductTypeName,TotalTrades");
            foreach (var t in data)
                w.WriteLine($"{t.ProductTypeName},{t.TotalTrades}");

            // 2) call Python script (unchanged)
            var script = Path.Combine(_scriptsFolder, "generate_product_trade_chart.py");
            var psi = new ProcessStartInfo
            {
                FileName            = "python",
                Arguments           = $"\"{script}\" \"{csvPath}\" \"{pngPath}\"",
                RedirectStandardError = true,
                UseShellExecute     = false
            };
            using var proc = Process.Start(psi)
                          ?? throw new InvalidOperationException("Cannot start Python");
            var err = await proc.StandardError.ReadToEndAsync();
            await proc.WaitForExitAsync();
            if (!string.IsNullOrEmpty(err))
                _logger.LogError(err);

            // always return the web‐relative URL
            return "/charts/product_trades.png";
        }
    }
}
```

---

## 2) Kick off one generation on startup

In your **Server** app’s `Program.cs`, before you map endpoints, do:

```csharp
var builder = WebApplication.CreateBuilder(args);
// … register services as before …
builder.Services.AddScoped<IOracleDataService, OracleDataService>();
builder.Services.AddScoped<IChartGeneratorService, ChartGeneratorService>();

var app = builder.Build();

// **ONE-TIME PRE-RENDER**  
using (var scope = app.Services.CreateScope())
{
    var oracle   = scope.ServiceProvider.GetRequiredService<IOracleDataService>();
    var chartGen = scope.ServiceProvider.GetRequiredService<IChartGeneratorService>();
    var data     = await oracle.GetProductTradeCountsAsync(DateTime.Now.AddDays(-7));
    await chartGen.GenerateProductTradeChartAsync(data);
}

// rest of your pipeline…
app.UseStaticFiles();
app.UseRouting();
app.MapRazorPages();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");
app.Run();
```

This ensures `/wwwroot/charts/product_trades.png` exists before any user ever hits the site.

---

## 3) Simplest Blazor page to render it

Create or edit `Pages/Index.razor`:

```razor
@page "/"
@inject IWebHostEnvironment Env

<h3>Product Trades in Last 7 Days</h3>

<img src="charts/product_trades.png"
     alt="Trades Chart"
     style="max-width:100%; height:auto;" />

<p>
  <small>
    Last updated:
    @File.GetLastWriteTime(
        Path.Combine(Env.ContentRootPath, "wwwroot", "charts", "product_trades.png")
      ).ToLocalTime():f
  </small>
</p>
```

And at the top of the file:

```razor
@using System.IO
```

This will:

* Always show the single, pre‐rendered PNG
* Display the file’s last‐write time as your “Last updated”
* Never spin or get stuck (no async loading needed)

---

### Directory layout recap

```
/StarTrends
  /PythonScripts
    generate_product_trade_chart.py
  /chart_data
    product_trades.csv       ← always overwritten
  /wwwroot
    /charts
      product_trades.png     ← always overwritten
  /Pages
    _Host.cshtml
    Index.razor
  Program.cs
  …
```

Rebuild & run both your Worker (if you still have it) and the Server site together (via “Multiple Startup Projects”). When you navigate to `/`, you’ll see your latest chart instantly.
