**Identifying HttpClient issue**

The user encountered an "InvalidOperationException" when trying to use a relative URL in Blazor. This likely happened because the `HttpClient` BaseAddress isn't set, which is required for relative URLs. In Blazor Server, this BaseAddress needs to be configured manually in Program.cs using `AddHttpClient`. On the other hand, Blazor WebAssembly auto-configures the BaseAddress. To fix it, they'll need to configure their `HttpClient` in Blazor Server by setting it properly in the service configuration.

**Resolving HttpClient BaseAddress issue**

When using relative URLs like "api/...", an "invalid request URI" error occurs if the `HttpClient`'s `BaseAddress` isn't set. To fix this, the BaseAddress can be specified in `Program.cs`. In Blazor Server, use `builder.Services.AddHttpClient<HttpClient>(client => client.BaseAddress = new Uri(builder.HostEnvironment.BaseAddress));`, or for a direct URL, inject `NavigationManager` to build an absolute path. Alternatively, set the HTTP client's BaseAddress directly to ensure accuracy when making requests.


Thought for 8 seconds


Here’s the *one-image* setup you had working, with just a tiny tweak so you won’t get that “invalid URI” error. We’re going back to exactly what rendered for you before, but now we build an **absolute** URL for HttpClient.

---

### 1) `Program.cs` (no changes from your last working)

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddScoped<IGraphDataRepo, OracleDataRepo>();
builder.Services.AddScoped<IGraphService, GraphService>();

// we’ll use HttpClient in the component, so just register the default
builder.Services.AddHttpClient();

builder.Services.AddRazorPages();
builder.Services.AddServerSideBlazor();

var app = builder.Build();

app.UseHttpsRedirection();
app.UseStaticFiles();
app.UseRouting();

app.MapControllers();
app.MapBlazorHub();
app.MapFallbackToPage("/_Host");

app.Run();
```

---

### 2) `GraphController.cs` (serve the cached PNG only)

```csharp
using Microsoft.AspNetCore.Mvc;
using StarTrends.Services;

namespace StarTrends.Controllers
{
    [ApiController]
    [Route("api/graphs")]
    public class GraphController : ControllerBase
    {
        private readonly IGraphService _svc;
        public GraphController(IGraphService svc) => _svc = svc;

        [HttpGet("otc-product-types")]
        public async Task<IActionResult> Get()
        {
            var png = await _svc.GetCachedChartAsync();
            return File(png, "image/png");
        }
    }
}
```

---

### 3) `GraphService.cs` (exactly as before)

Make sure you have your `RegenerateChartAsync()` already run *once* (so the file exists), then you only need:

```csharp
public async Task<byte[]> GetCachedChartAsync()
{
    var path = Path.Combine(AppContext.BaseDirectory, "wwwroot", "charts", "otc-product-types.png");
    return await File.ReadAllBytesAsync(path);
}
```

---

### 4) **Updated** `Shared/ChartViewer.razor`

```razor
@inject HttpClient Http
@inject NavigationManager Nav

<img src="@($"data:image/png;base64,{_base64}")"
     alt="OTC Product Types"
     style="max-width:100%;" />

@code {
    private string _base64 = "";

    protected override async Task OnInitializedAsync()
    {
        // build absolute URL so HttpClient has a BaseAddress it can use
        var url = $"{Nav.BaseUri}api/graphs/otc-product-types";

        // fetch the raw bytes
        var bytes = await Http.GetByteArrayAsync(url);

        // convert to inline base64 PNG
        _base64 = Convert.ToBase64String(bytes);
    }
}
```

**Why this fixes the URI error**

* By concatenating `Nav.BaseUri` (which is your app’s origin + “/”) to the API path, you give `Http.GetByteArrayAsync` an **absolute** URI.
* You’ll once again get exactly one chart, rendered as an inline `<img>` in your Blazor page.

Drop *only* those four files in, rebuild, and you should see your single chart come back.
