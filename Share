Yes! That's a great UX idea üí°

We can easily let the user **toggle between**:

- A **normal scale** chart (default)
- A **logarithmic or zoomed-in version** to make smaller values visible

---

### üîÅ Proposed UI Flow:

1. ‚ûï **Two Buttons**:
   - `Show Normal Scale`
   - `Show Zoomed Scale`

2. When clicked, they pass a flag (e.g. `useLogScale`) to JavaScript interop.

3. JS will then re-render the Plotly chart with adjusted Y-axis options:
   - **Normal:** Linear axis
   - **Zoomed:** Logarithmic scale or narrowed range

---

### ‚úÖ Implementation Plan (Modular Plotly Setup)

#### 1. Update the HTML in `Counter.razor`

```razor
<h3>Feature Usage Chart</h3>

<div class="mb-3">
    <button class="btn btn-primary me-2" @onclick="() => GenerateGraph(false)">Show Normal Scale</button>
    <button class="btn btn-outline-secondary" @onclick="() => GenerateGraph(true)">Show Zoomed Scale</button>
</div>

<div id="featureUsageChart" style="width: 100%; height: 400px;"></div>
```

---

#### 2. Modify your JS Interop (`wwwroot/js/plotlyInterop.js`)

Update the `renderPlotlyBarChart` to accept a `useLogScale` flag:

```js
window.renderPlotlyBarChart = (chartId, chartData, useLogScale) => {
    const layout = {
        title: chartData.title,
        xaxis: { title: chartData.xLabel },
        yaxis: {
            title: chartData.yLabel,
            type: useLogScale ? 'log' : 'linear'
        }
    };

    const trace = {
        x: chartData.labels,
        y: chartData.values,
        type: 'bar',
        marker: { color: 'rgb(54, 162, 235)' }
    };

    Plotly.newPlot(chartId, [trace], layout);
};
```

---

#### 3. Update C# logic in `Counter.razor`

```razor
@inject IJSRuntime JSRuntime
@inject IOracleDataService DataService

@code {
    private List<string> labels = new();
    private List<double> values = new();

    private async Task GenerateGraph(bool useLogScale)
    {
        var data = await DataService.GetFeatureUsageAsync();
        labels = data.Select(d => d.Feature).ToList();
        values = data.Select(d => (double)d.UsageCount).ToList();

        var chartData = new
        {
            labels,
            values,
            title = "Feature Usage in Last 30 Days",
            xLabel = "Feature",
            yLabel = "Count"
        };

        await JSRuntime.InvokeVoidAsync("renderPlotlyBarChart", "featureUsageChart", chartData, useLogScale);
    }
}
```

---

### ‚úÖ Result:

- The chart is rendered only when a button is clicked
- User can **toggle between full and zoomed-in view**
- Great for charts with large gaps in value ranges

---

Shall I generate the full `.razor` and JS file with this logic for you?
